{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ILLIXR Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-illixr","text":"","title":"Welcome to ILLIXR"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"components/open_vins/","text":"OpenVINS OpenVINS blurb","title":"OpenVINS"},{"location":"components/open_vins/#openvins","text":"OpenVINS blurb","title":"OpenVINS"},{"location":"core/phonebook/","text":"Phonebook There is a Dependency Injection service called phonebook . One can provide an implementation a base class by, pb->register_impl<base_class>(base_class_impl) , and later on, one can find that implementation by, pb->lookup_impl<base_class>() . This returns base_class* or a sub_class* which has been cast to a base_class* . Using services It's as easy as switchboard* sb = pb->lookup_impl<switchboard>(); std::unique_ptr<reader_latest<pose_type>> slow_pose_plug = sb->subscribe_latest<pose_type>(\"slow_pose\"); Defining services If the implementation resides in another plugin, make an 'abstract' base class in common/ with virtual method_name(Args args) = 0 and virtual ~base_class() { } , and subclass it in your plugin. Other plugins will still be able to treat it as the 'base class' except the virtual methods direct control to the implementation in your plugin. If the implementation is simple and unchanging, it can reside in common/ . For example, the global_config really has no implementation; it is just the holder class for a few variables. In either case, the base class must inherit from ILLIXR::service . Make sure to load plugins (in ./test.sh) in order, such that services will be registered before they are looked up. You may be wondering if new plugins should be publish phonebook service or a switchboard plug. Switchboard is optimized for high-bandwidth event-streams, which can be subscribed synchronously or asynchronously. Phonebook is for everything which does not fit that restrictive but optimized model. Other Changes Managed threadloop available in common/ as threadloop' instead of component . Components which do not need a managed threadloop should just extend plugin . Build script builds OpenCV if none is detected. Constructors should have one arg, phonebook* pb instead of switchboard* sb , which is now a phonebook service. PLUGIN_MAIN(plugin_class) will export a class instead of create_component ; all of the initialization code should go in the constructor. class pose_prediction : public threadloop { public: pose_prediction(phonebook* pb) : sb{pb->lookup_impl<switchboard>()} // first we get lookup the switchboard , _m_slow_pose{sb->subscribe_latest<pose_type>(\"slow_pose\")} // and then use it to look up the plugs , _m_imu{sb->subscribe_latest<imu_type>(\"imu0\")} , _m_fast_pose{sb->publish<pose_type>(\"fast_pose\")} { /* ... */ } /* ... */ private: switchboard * const sb; /* ... */ }; PLUGIN_MAIN(pose_predict)","title":"Phonebook"},{"location":"core/phonebook/#phonebook","text":"There is a Dependency Injection service called phonebook . One can provide an implementation a base class by, pb->register_impl<base_class>(base_class_impl) , and later on, one can find that implementation by, pb->lookup_impl<base_class>() . This returns base_class* or a sub_class* which has been cast to a base_class* .","title":"Phonebook"},{"location":"core/phonebook/#using-services","text":"It's as easy as switchboard* sb = pb->lookup_impl<switchboard>(); std::unique_ptr<reader_latest<pose_type>> slow_pose_plug = sb->subscribe_latest<pose_type>(\"slow_pose\");","title":"Using services"},{"location":"core/phonebook/#defining-services","text":"If the implementation resides in another plugin, make an 'abstract' base class in common/ with virtual method_name(Args args) = 0 and virtual ~base_class() { } , and subclass it in your plugin. Other plugins will still be able to treat it as the 'base class' except the virtual methods direct control to the implementation in your plugin. If the implementation is simple and unchanging, it can reside in common/ . For example, the global_config really has no implementation; it is just the holder class for a few variables. In either case, the base class must inherit from ILLIXR::service . Make sure to load plugins (in ./test.sh) in order, such that services will be registered before they are looked up. You may be wondering if new plugins should be publish phonebook service or a switchboard plug. Switchboard is optimized for high-bandwidth event-streams, which can be subscribed synchronously or asynchronously. Phonebook is for everything which does not fit that restrictive but optimized model.","title":"Defining services"},{"location":"core/phonebook/#other-changes","text":"Managed threadloop available in common/ as threadloop' instead of component . Components which do not need a managed threadloop should just extend plugin . Build script builds OpenCV if none is detected. Constructors should have one arg, phonebook* pb instead of switchboard* sb , which is now a phonebook service. PLUGIN_MAIN(plugin_class) will export a class instead of create_component ; all of the initialization code should go in the constructor. class pose_prediction : public threadloop { public: pose_prediction(phonebook* pb) : sb{pb->lookup_impl<switchboard>()} // first we get lookup the switchboard , _m_slow_pose{sb->subscribe_latest<pose_type>(\"slow_pose\")} // and then use it to look up the plugs , _m_imu{sb->subscribe_latest<imu_type>(\"imu0\")} , _m_fast_pose{sb->publish<pose_type>(\"fast_pose\")} { /* ... */ } /* ... */ private: switchboard * const sb; /* ... */ }; PLUGIN_MAIN(pose_predict)","title":"Other Changes"},{"location":"core/spindle/","text":"Spindle Spindle is at the heart of the illixr runtime. here is an explanation:","title":"Spindle"},{"location":"core/spindle/#spindle","text":"Spindle is at the heart of the illixr runtime. here is an explanation:","title":"Spindle"}]}